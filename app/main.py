#!/usr/bin/env python3

import jwt
import time
import uvicorn
from os import getenv
from fastapi import FastAPI, Depends, HTTPException, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2AuthorizationCodeBearer
from motor.motor_asyncio import AsyncIOMotorClient
from jsonschema.exceptions import ValidationError
import aioredis

from .rest import Rest
from .pubsub import PubSub
from .schema import validate

app = FastAPI()

# Allow cross-origin requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"]
)

# Token authorization (generated by auth container)
secret = getenv('AUTH_SECRET')
def token_to_owner_id(token: str|None=None):
    # In case no authorization was provided
    if not token: return token

    # Assert that the token is valid
    try:
        token = jwt.decode(token, secret, algorithms=["HS256"])
    except:
        raise HTTPException(status_code=400, detail="malformed token")
    if not token["type"] == "token":
        raise HTTPException(status_code=400, detail="invalid code type.")

    return token["owner_id"]

@app.on_event("startup")
async def startup():
    # Initialize the database
    client = AsyncIOMotorClient('mongo')
    db = client.graffiti.objects

    # Create indexes if they don't already exist
    await db.create_index('_expandedContexts._queryFailsWithout.$**')
    await db.create_index('_expandedContexts._queryPassesWithout.$**')
    await db.create_index('_externalID')
    await db.create_index('_tombstone')
    await db.create_index('_object._by')
    await db.create_index('_object._to')
    await db.create_index('_object.$**')

    # Initialize the pubsub/locking system
    redis = aioredis.from_url("redis://redis", decode_responses=True)

    # Initialize database interfaces
    app.rest   = Rest  (db, redis)
    app.pubsub = PubSub(db, redis)

@app.websocket("/")
async def query_socket(ws: WebSocket, owner_id: str|None=Depends(token_to_owner_id)):
    await ws.accept()

    # Register with the pub/sub manager
    async with app.pubsub.register(ws) as socket_id:

        # Send messages back and forth
        while True:
            try:
                msg = await ws.receive_json()
                await reply(ws, msg, socket_id, owner_id)
            except:
                break

async def reply(ws, msg, socket_id, owner_id):
    # Initialize the output
    output = {}
    if 'messageID' in msg:
        output['messageID'] = msg['messageID']

    try:
        # Make sure the message is formatted properly
        validate(msg, owner_id)

        if msg['type'] == 'update':
            await app.rest.update(msg['object'], msg['query'], owner_id)

        elif msg['type'] == 'remove':
            await app.rest.remove(msg['objectID'], owner_id)

        elif msg['type'] == 'subscribe':
            audit = False
            if 'audit' in msg: audit = msg['audit']
            await app.pubsub.subscribe(msg['query'], msg['since'], audit, socket_id, msg['queryID'], owner_id)

        elif msg['type'] == 'unsubscribe':
            await app.pubsub.unsubscribe(socket_id, msg['queryID'])

    except ValidationError as e:
        output['type'] = 'error'
        output['reason'] = 'validation'
        output['detail'] = str(e).split('\n')[0]
        await ws.send_json(output)

    except Exception as e:
        output['type'] = 'error'
        output['reason'] = 'unknown'
        output['detail'] = str(e)
        await ws.send_json(output)

    else:
        output['type'] = 'success'
        await ws.send_json(output)

if __name__ == "__main__":
    args = {}
    if getenv('DEBUG') == 'true':
        args['reload'] = True
    uvicorn.run('app.main:app', host='0.0.0.0', **args)
